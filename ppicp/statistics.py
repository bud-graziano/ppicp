#!/usr/bin/env python

"""
ppicp.statistics
~~~~~~~~~~~~~~~~

A collection of functions that retrieve information from the files generated by the PPI calculations
which can be used for statistics reports.
"""

import os
import cPickle
import csv
import sys
import re

PARENT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))
sys.path.append(PARENT_DIR)

from ppicp import initialize

LOGGER = initialize.init_logger(__name__)


def count_edges_in_ppi_aa_graph(path):
    """
    Takes the path to a file that stores edges for one protein complex (``.fanmod`` file) and counts
    the edges.

    :param path: Path to file that contains the edges.
    :return: the number of edges in the PPI AA graph.
    """
    with open(path, 'r') as f:
        simple_file = f.readlines()
    return len(simple_file)


def count_vertices_in_ppi_aa_graph(path):
    """
    Takes the path to a file that stores edges for one protein complex (``.fanmod`` file) and counts
    the vertices that are involved in edges.

    :param path: Path to file that contains the vertices.
    :return: the number of vertices in the PPI AA graph.
    """
    with open(path, 'r') as f:
        simple_file = f.read()

    vertices = re.split('\n| ', simple_file)
    vertices_id = []
    for vtx in vertices:
        if not vtx == '':
            vertices_id.append(int(vtx))
    try:
        return max(vertices_id) + 1  # +1 because .fanmod starts counting its ids at 0
    except ValueError as err:
        LOGGER.warning("%s\nFile was most likely empty.", err)
        return 0


def count_aas_in_aa_graph(aagraph_path):
    """
    Takes the path to a ``aagraph.gml`` file and counts how many vertices/amino acids are part of
    that protein in total.

    :param aagraph_path: Path to file that contains the vertices/amino acids.
    :return: the number of vertices/amino acids in that AA graph.
    """
    with open(aagraph_path, 'r') as f:
        aagraph = f.readlines()

    vertices_ids = []
    for vtx in aagraph:
        if vtx.startswith("    id"):  # indention is important -> gets all the vertex ids
            vertices_ids.append(int(vtx.split("id ")[1].strip()))
    return max(vertices_ids)


def count_all_contacts(stats_file):
    """
    Takes the path to a ``.stats`` file and count the different types of detected contacts on atom
    level. These contacts are not the same as edges in the PPI AA graph, since we are now counting
    contacts on an atom-atom level while the PPI AA graph shows contacts on a residue level.

    :param stats_file: Path to the .stats file.
    :return: dictionary of all contact types and their abundances.
    """
    all_contact_types = {'BBHB': 0, 'BBBH': 0, 'IVDW': 0, 'ISS': 0, 'BCHB': 0, 'BCBH': 0, 'CBHB': 0,
                         'CBBH': 0, 'CCHB': 0, 'CCBH': 0, 'BB': 0, 'CB': 0, 'BC': 0, 'CC': 0,
                         'BL': 0, 'LB': 0, 'CL': 0, 'LC': 0, 'LL': 0, 'NHPI': 0, 'PINH': 0,
                         'CAHPI': 0, 'PICAH': 0, 'CNHPI': 0, 'PICNH': 0, 'SHPI': 0, 'PISH': 0,
                         'XOHPI': 0, 'PIXOH': 0, 'PROCDHPI': 0, 'PIPROCDH': 0, 'CCACOH': 0,
                         'CCOCAH': 0, 'BCACOH': 0, 'BCOCAH': 0}

    with open(stats_file, 'r') as f:
        text = f.readlines()

    for line in text:
        if ':' in line:     # to make sure this a valid line and no empty line at file end.
            c_type = line.split(": ")[0]
            c_num = int(line.split(": ")[1].rstrip('\n'))
            all_contact_types[c_type] += c_num

    return all_contact_types


def count_atom_num_contacts(csv_file):
    """
    Takes the path to a ``atom_atom_contacts.csv`` file and counts how many contacts one single atom
    is part of.

    :param csv_file: Path to the ``atom_atom_contacts.csv`` file.
    :return: a dictionary with all atoms and the amount of contacts they part of.
    """
    pdb_id = csv_file[len(csv_file)-27:len(csv_file)-23]
    all_atom_contacts = {}
    with open(csv_file, 'rb') as csvfile:
        text = csv.reader(csvfile, delimiter=';')

        for line in text:
            # Find chain_id and atom_id for residue A.
            chain_id = re.compile(r'\b({0}.?)\b'.format('Chain='),
                                  flags=re.IGNORECASE).search(line[1]).group().split(r'=')[1]
            atom_id = re.compile(r'\b({0}.*?\d)\b'.format('Atom'),
                                 flags=re.IGNORECASE).search(line[1]).group().split(r'#')[1]

            # An atom id equal to 0 usually denotes H atoms added by the Reduce software which we
            # want to exclude here atm.
            if not atom_id == '0':
                key = (pdb_id, chain_id, atom_id)
                if key not in all_atom_contacts:
                    all_atom_contacts[key] = 1
                else:
                    all_atom_contacts[key] += 1

            # Find chain_id and atom_id for residue B.
            chain_id = re.compile(r'\b({0}.?)\b'.format('Chain='), flags=re.IGNORECASE).search(
                line[2]).group().split(r'=')[1]
            atom_id = re.compile(r'\b({0}.*?\d)\b'.format('Atom'), flags=re.IGNORECASE).search(
                line[2]).group().split(r'#')[1]

            # An atom id equal to 0 usually denotes H atoms added by the Reduce software which we
            # want to exclude here atm.
            if not atom_id == '0':
                key = (pdb_id, chain_id, atom_id)
                if key not in all_atom_contacts:
                    all_atom_contacts[key] = 1
                else:
                    all_atom_contacts[key] += 1

    return all_atom_contacts


def amount_atom_contacts(all_contacts_dict):
    """
    Calculate how many contacts on atom-atom level occurred in total.

    :param all_contacts_dict: Dictionary containing all contact types.
    :return: total amount of contact types on atom-atom level.
    """
    total = all_contacts_dict['BBHB'] + all_contacts_dict['BBBH'] + all_contacts_dict['IVDW'] \
            + all_contacts_dict['ISS'] + all_contacts_dict['BCHB'] + all_contacts_dict['BCBH'] \
            + all_contacts_dict['CBHB'] + all_contacts_dict['CBBH'] + all_contacts_dict['CCHB'] \
            + all_contacts_dict['CCBH'] + all_contacts_dict['BL'] + all_contacts_dict['LB'] \
            + all_contacts_dict['CL'] + all_contacts_dict['LC'] + all_contacts_dict['LL'] \
            + all_contacts_dict['NHPI'] + all_contacts_dict['PINH'] + all_contacts_dict['CAHPI'] \
            + all_contacts_dict['PICAH'] + all_contacts_dict['CNHPI'] + all_contacts_dict['PICNH'] \
            + all_contacts_dict['SHPI'] + all_contacts_dict['PISH'] + all_contacts_dict['XOHPI'] \
            + all_contacts_dict['PIXOH'] + all_contacts_dict['PROCDHPI'] \
            + all_contacts_dict['PIPROCDH'] + all_contacts_dict['CCACOH'] \
            + all_contacts_dict['CCOCAH'] + all_contacts_dict['BCACOH'] \
            + all_contacts_dict['BCOCAH']
    return total


def get_chem_props(aagraph_id_file):
    """
    Get the different chemical properties of amino acids and count them.

    There are two common systems to categorize chemical properties of amino acids, one is the three
    class system and the other the five class system. Chemical properties of amino acids are counted
    for both systems here.
    Since the input is a ``aagraph_simple.id`` file, the chemical properties for amino acids
    contributing to protein-protein interactions are counted.

    :param aagraph_id_file: Path to a ``aagraph_simple.id`` file.
    :return: two dictionaries containing the abundances of chemical properties according to the
    three class system and five class system, respectively.
    """
    with open(aagraph_id_file, 'r') as f:
        aagraph = f.readlines()

    # Get a dictionary storing all 20 amino acids and their chemical properties
    with open(os.path.join(initialize.BIN_DIR, 'chem_props_3.pickle'), 'rb') as in_file:
        chem_props_3 = cPickle.load(in_file)

    with open(os.path.join(initialize.BIN_DIR, 'chem_props_5.pickle'), 'rb') as in_file:
        chem_props_5 = cPickle.load(in_file)

    chem_props_count_5 = {'SMALL_APOLAR': 0,
                          'HYDROPHOBIC': 0,
                          'POLAR': 0,
                          'NEGATIVE_CHARGE': 0,
                          'POSITIVE_CHARGE': 0,
                          'UNKNOWN': 0
                         }

    chem_props_count_3 = {'POLAR_UNCHARGED': 0,
                          'POLAR_CHARGED': 0,
                          'HYDROPHOBIC': 0,
                          'UNKNOWN': 0
                         }

    # Count the occurrence of chemical properties
    for line in aagraph:
        if not line.startswith('#'):  # '#' indicates comments
            amino_acid = line.split(',')[3].rstrip('\n')    # file is in csv format
            if amino_acid in chem_props_3:
                prop_3 = chem_props_3.get(amino_acid)
                chem_props_count_3[prop_3] += 1
            else:
                chem_props_count_3['UNKNOWN'] += 1

            if amino_acid in chem_props_5:
                prop_5 = chem_props_5.get(amino_acid)
                chem_props_count_5[prop_5] += 1
            else:
                chem_props_count_5['UNKNOWN'] += 1
    return chem_props_count_3, chem_props_count_5
